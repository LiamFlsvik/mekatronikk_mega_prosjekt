[1mdiff --git a/bringup_robot/launch/bringup_robot.launch.py b/bringup_robot/launch/bringup_robot.launch.py[m
[1mindex c798482..208bee8 100644[m
[1m--- a/bringup_robot/launch/bringup_robot.launch.py[m
[1m+++ b/bringup_robot/launch/bringup_robot.launch.py[m
[36m@@ -1,34 +1,3 @@[m
 from launch import LaunchDescription[m
[31m-from moveit_configs_utils import MoveItConfigsBuilder[m
 [m
[31m-#The launch config [m
[31m-#[m
[31m-#[m
[31m-launch_arguments = {[m
[31m-    "robot_ip": "xxx.yyy.zzz.www",[m
[31m-    "use_fake_hardware": "true",[m
[31m-    "gripper": "robotiq_2f_85",[m
[31m-    "dof": "7",[m
[31m-}[m
 [m
[31m-# Load the robot configuration[m
[31m-moveit_config = ([m
[31m-    MoveItConfigsBuilder([m
[31m-        "gen3", package_name="kinova_gen3_7dof_robotiq_2f_85_moveit_config"[m
[31m-    )[m
[31m-    .robot_description(mappings=launch_arguments)[m
[31m-    .trajectory_execution(file_path="config/moveit_controllers.yaml")[m
[31m-    .planning_scene_monitor([m
[31m-        publish_robot_description=True, publish_robot_description_semantic=True[m
[31m-    )[m
[31m-    .planning_pipelines([m
[31m-        pipelines=["ompl", "stomp", "pilz_industrial_motion_planner"][m
[31m-    )[m
[31m-    .to_moveit_configs()[m
[31m-)[m
[31m-[m
[31m-def generate_launch_description():[m
[31m-    [m
[31m-    moveit_nodes = Node([m
[31m-[m
[31m-    )[m
\ No newline at end of file[m
[1mdiff --git a/robot_controller/config/parameters.yaml b/robot_controller/config/parameters.yaml[m
[1mindex bb233a7..7fa7543 100644[m
[1m--- a/robot_controller/config/parameters.yaml[m
[1m+++ b/robot_controller/config/parameters.yaml[m
[36m@@ -13,5 +13,5 @@[m [mrobot_controller_node:[m
     camera_offset_width: 0.03375 [m
     scan_angle_start: 0.9[m
     scan_angle_end: 2.1[m
[31m-    cube_point_offset: 0.07[m
[32m+[m[32m    cube_point_offset: 0.065[m
     [m
\ No newline at end of file[m
[1mdiff --git a/robot_controller/include/robot_controller.hpp b/robot_controller/include/robot_controller.hpp[m
[1mindex 0a851e4..d89aaea 100644[m
[1m--- a/robot_controller/include/robot_controller.hpp[m
[1m+++ b/robot_controller/include/robot_controller.hpp[m
[36m@@ -119,7 +119,7 @@[m [mbool move_robot(double x, double y, double z, double roll = 0, double pitch = -M[m
       RCLCPP_INFO(logger, "%sposition: x: %f, y: %f, z: %f %s",COLOR_GREEN, target_pose.position.x, target_pose.position.y, target_pose.position.z, COLOR_RESET);[m
       RCLCPP_INFO(logger, "%sorientation: roll: %f, pitch: %f, yaw: %f %s",COLOR_GREEN, roll, pitch, yaw, COLOR_RESET);[m
       move_group_interface.execute(plan);[m
[31m-      std::this_thread::sleep_for(std::chrono::milliseconds(2000));[m
[32m+[m[32m      std::this_thread::sleep_for(std::chrono::milliseconds(1000));[m
       return true;[m
 [m
     } else {[m
[36m@@ -138,7 +138,7 @@[m [mbool move_robot(double x, double y, double z, double roll = 0, double pitch = -M[m
       if (result == moveit::core::MoveItErrorCode::SUCCESS) {[m
           RCLCPP_INFO(logger, "%sHome position successfully reached%s", COLOR_GREEN, COLOR_RESET);[m
           move_group_interface.execute(plan);[m
[31m-          std::this_thread::sleep_for(std::chrono::milliseconds(5000));[m
[32m+[m[32m          std::this_thread::sleep_for(std::chrono::milliseconds(1000));[m
           return true;[m
       } else {[m
           RCLCPP_ERROR(logger, "Home planning failed");[m
[36m@@ -345,18 +345,18 @@[m [mprivate:[m
       if(msg->command == "MOVE_HOME") {[m
         feedback.success = go_to_home_position();[m
         feedback.message = feedback.success ? "Home reached" : "Move home failed";[m
[31m-        std::this_thread::sleep_for(std::chrono::milliseconds(5000));[m
[32m+[m[32m        std::this_thread::sleep_for(std::chrono::milliseconds(1000));[m
 [m
       }[m
       else if(msg->command == "SCAN") {[m
         feedback.success = scan_workplace();[m
         feedback.message = feedback.success ? "Scan completed" : "Scan failed";[m
[31m-        std::this_thread::sleep_for(std::chrono::milliseconds(5000));[m
[32m+[m[32m        std::this_thread::sleep_for(std::chrono::milliseconds(1000));[m
       }[m
       else if(msg->command == "VERIFY_CUBES") {[m
         feedback.success = point_to_cubes();[m
         feedback.message = feedback.success ? "Pointing completed" : "Pointing failed";[m
[31m-        std::this_thread::sleep_for(std::chrono::milliseconds(3000));[m
[32m+[m[32m        std::this_thread::sleep_for(std::chrono::milliseconds(1000));[m
       }[m
       else {[m
         feedback.success = false;[m
[36m@@ -379,15 +379,13 @@[m [mprivate:[m
       double x = cube.position[0];[m
       double y = cube.position[1];[m
       double z = camera_height + cube_point_offset;[m
[31m-      double roll = 0;[m
[31m-      double pitch = -M_PI; [m
[31m-      double yaw = cube.angle+M_PI;[m
[32m+[m[41m    [m
       //double roll = 0;[m
       //double yaw = cube.angle;[m
       //double pitch = 0;[m
[31m-      move_robot(x,y,scan_height,roll, pitch, yaw);[m
[32m+[m[32m      move_robot(x,y,scan_height);[m
 [m
[31m-      if (!move_robot(x, y, z, roll, pitch, yaw)) {[m
[32m+[m[32m      if (!move_robot(x, y, z)) {[m
         RCLCPP_ERROR(logger, "Failed to point to %s cube at (%f, %f)", cube.color.c_str(), x, y);[m
         return false;[m
       }[m
[1mdiff --git a/scene_handler/include/scene_handler.hpp b/scene_handler/include/scene_handler.hpp[m
[1mindex 2b632a1..e51905d 100644[m
[1m--- a/scene_handler/include/scene_handler.hpp[m
[1m+++ b/scene_handler/include/scene_handler.hpp[m
[36m@@ -58,6 +58,7 @@[m [mclass scene_handler: public rclcpp::Node{[m
     //TODO: move this section to updated_cube_array, the joint_values are not used in this function, but rather used as a lazy way to update the x, y, z, roll  values of the robot base in the matrix_transformations class.[m
     joint_values = msg->position;   [m
     // TF2-based lookup for tool0[m
[32m+[m[41m    [m
     geometry_msgs::msg::TransformStamped transformStamped;[m
     try {[m
       transformStamped = tf_buffer_.lookupTransform([m
[36m@@ -127,7 +128,6 @@[m [mclass scene_handler: public rclcpp::Node{[m
           RCLCPP_WARN(this->get_logger(), "Unknown color: %s", cube.color.c_str());[m
           continue; // Skip this cube if the color is unknown[m
         }[m
[31m-[m
         if(virtual_boxes[index].update(cube_coordinates, cube.angle)){[m
           if(cubes_found[index]){[m
             return;[m
[36m@@ -135,6 +135,8 @@[m [mclass scene_handler: public rclcpp::Node{[m
             cubes_found[index] = false;[m
             std::vector<double> box_position = virtual_boxes[index].get_position_filtered();[m
             remove_collision_object(cube.color);[m
[32m+[m[32m            std::this_thread::sleep_for(std::chrono::milliseconds(10));[m
[32m+[m
             add_box(cube.color, {box_position[0], box_position[1], 0}, virtual_boxes[index].get_yaw());[m
           }[m
         }  [m
[36m@@ -157,9 +159,7 @@[m [mclass scene_handler: public rclcpp::Node{[m
 [m
   void create_safe_zone(){[m
     add_collision_object("Robot base plate",{0.0,0.0,-0.015}, 0.0, {0.45, 0.25,0.015},"grey");[m
[31m-    add_collision_object("Working scene",{0.0, 0.25, -working_table_z-0.015}, 0.0,{working_table_x, working_table_y, working_table_z}, "grey");[m
[31m-    add_collision_object("Virtual wall 1",{working_table_x,0,0}, 0.0, {0.03,1.0,1.0}, "grey");[m
[31m-    [m
[32m+[m[32m    add_collision_object("Working scene",{0.0, 0.25, working_table_z}, 0.0,{working_table_x, working_table_y, -working_table_z}, "grey");[m
   }[m
 [m
   static std_msgs::msg::ColorRGBA object_color(std::string color = "green") {[m
[36m@@ -305,7 +305,7 @@[m [mclass scene_handler: public rclcpp::Node{[m
   [m
     const double working_table_x = 0.85;[m
     const double working_table_y = 0.80;[m
[31m-    const double working_table_z = 0.01;[m
[32m+[m[32m    const double working_table_z =-0.016;[m
 [m
     int object_counter = 0;[m
 [m
